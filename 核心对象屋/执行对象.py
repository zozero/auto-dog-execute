import os.path
import time

from pandas.core.indexing import _LocIndexer

from 公共函数屋.字符转换 import 字符串转换
from 数据类型屋.接收类型 import 任务数据类
from 数据类型屋.结果类型 import 结果类
from 核心对象屋.安卓对象 import 安卓指令类, 安卓预处理类
from 核心对象屋.方法对象 import 匹配方法类, 方法预处理类
from 通用对象屋.委托对象 import 委托对象类
from 通用对象屋.表格对象 import 逗号分隔符类

目录名称对象 = {
    '表格目录': '表格文件屋',
    '图片目录': '图片存取屋',
    '任务目录': '任务间',
    '步骤目录': '步骤间',
    '方法目录': '方法间',
}


class 执行类:
    # 最为核心的类，最要是收集数据、识别方法执行、模拟器行为执行
    # 它只执行一个步骤
    判断结果: 结果类

    def __init__(self, 项目名: str, 任务数据):
        print("执行类")
        self.项目名 = 项目名
        self.任务数据 = 任务数据
        self.步骤数据 = None
        self.行为参数 = {}

        self.搜集参数()
        self.统筹过程()

    def 搜集参数(self):
        print("搜集参数")
        文件路径 = os.path.join(目录名称对象['表格目录'], self.项目名, 目录名称对象['步骤目录'],
                                self.任务数据['名称'] + '.csv')
        表格文件 = 逗号分隔符类(文件路径)
        步骤列表 = 表格文件.数据列表
        self.步骤数据 = 步骤列表[self.任务数据['编号']]

    def 统筹过程(self):
        print("统筹过程")
        # self.界面识别(self.步骤数据['界面编码'])

        self.位置判定(self.步骤数据['方法编码'])

        self.执行行为(self.步骤数据['行为编码'])

        # self.动后判定()
        # self.动后行为()

    def 界面判定(self, 编码):
        # 很多时候它不是必须的，但它是个可以做补充的策略。
        编码列表 = 字符串转换(编码)
        if 编码列表 and len(编码列表) == 2:
            self.识别位置(编码列表)

    def 位置判定(self, 编码):
        # 这几乎是必须要的，有了它就可以找到对应图片的位置，然后就是执行行为
        编码列表 = 字符串转换(编码)
        if 编码列表 and len(编码列表) == 2:
            self.识别位置(编码列表)

    def 识别位置(self, 编码列表):
        """
        识别位置需要两个编码，其中字母编码是用分辨匹配方法的
        :param 编码列表:
        :return:
        """
        print("识别位置")
        函数字典 = 匹配方法类.分配函数(编码列表[0])

        文件路径 = os.path.join(目录名称对象['表格目录'], self.项目名, 目录名称对象['方法目录'],
                                函数字典['文件名'] + '.csv')
        表格文件 = 逗号分隔符类(文件路径)
        参数字典 = 表格文件.数据列表[编码列表[1]].to_dict()

        参数字典['旧图路径'] = os.path.join(目录名称对象['图片目录'], self.项目名, 参数字典['图片名'] + '.jpg')
        预处理 = 方法预处理类(编码列表[0], 参数字典)
        self.判断结果: 结果类 = 函数字典['函数实例'](**预处理.参数字典)

        print("返回值", self.判断结果.__dict__())

    def 执行行为(self, 编码):
        编码列表 = 字符串转换(编码)
        if self.判断结果.状态:
            行为 = 安卓预处理类(编码列表, self.判断结果)
            行为.参数字典['行为函数'](**行为.参数字典)

    def 动后判定(self, 编码):
        print("动后判定")

    def 动后行为(self, 编码):
        print("动后行为")


class 任务类:
    # 发配任务给执行类
    def __init__(self, 任务数据: 任务数据类):
        print("任务类")
        self.任务数据 = 任务数据
        我的模拟器 = 安卓指令类(任务数据.模拟器的ip和端口)
        委托对象类.注册('我的模拟器', 我的模拟器)
        self.执行任务列表()

    def 获取数据(self, 任务名: str):
        print("获取数据")
        文件路径 = os.path.join(目录名称对象['表格目录'], self.任务数据.项目名, 目录名称对象['任务目录'],
                                任务名 + '.csv')
        表格文件 = 逗号分隔符类(文件路径)
        return 表格文件.文件数据表

    def 执行任务列表(self):
        for 任务 in self.任务数据.任务列表:
            self.执行任务(任务)

    def 执行任务(self, 任务名: str):
        print("执行任务")
        任务列表 = self.获取数据(任务名)
        for 序号 in 任务列表.index:
            任务数据 = 任务列表.loc[序号]
            if 任务数据['编号'] == 0:
                self.步骤组(self.任务数据.项目名, 任务数据)
            else:
                self.步骤(self.任务数据.项目名, 任务数据)

            # print(任务数据)

    def 步骤组(self, 项目名: str, 任务信息: _LocIndexer):
        # 先去拿一遍数据获取序号，然后发送给执行类。
        文件路径 = os.path.join(目录名称对象['表格目录'], 项目名, 目录名称对象['步骤目录'],
                                任务信息['名称'] + '.csv')
        表格文件 = 逗号分隔符类(文件路径)
        索引列表 = 表格文件.索引列表
        for i in 索引列表:
            print("步骤组", i)
            参数字典 = {
                '名称': 任务信息['名称'],
                '编号': i,
            }
            执行 = 执行类(项目名, 参数字典)
            time.sleep(2)

    def 步骤(self, 项目名: str, 任务信息: _LocIndexer):
        print("步骤")
        参数字典 = {
            '名称': 任务信息['名称'],
            '编号': 任务信息['编号'],
        }
        执行 = 执行类(项目名, 参数字典)
        time.sleep(5)
